var __importDefault=this&&this.__importDefault||function(f){return f&&f.__esModule?f:{"default":f}};Object.defineProperty(exports,"__esModule",{value:!0});exports.waLabelAssociationKey=exports.waMessageID=exports.waChatKey=void 0;
const WAProto_1=require("../../WAProto"),Defaults_1=require("../Defaults"),LabelAssociation_1=require("../Types/LabelAssociation"),Utils_1=require("../Utils"),WABinary_1=require("../WABinary"),make_ordered_dictionary_1=__importDefault(require("./make-ordered-dictionary")),object_repository_1=require("./object-repository"),waChatKey=f=>({key:g=>(f?g.pinned?"1":"0":"")+(g.archived?"0":"1")+(g.conversationTimestamp?g.conversationTimestamp.toString(16).padStart(8,"0"):"")+g.id,compare:(g,v)=>v.localeCompare(g)});
exports.waChatKey=waChatKey;const waMessageID=f=>f.key.id||"";exports.waMessageID=waMessageID;exports.waLabelAssociationKey={key:f=>f.type===LabelAssociation_1.LabelAssociationType.Chat?f.chatId+f.labelId:f.chatId+f.messageId+f.labelId,compare:(f,g)=>g.localeCompare(f)};const makeMessagesDictionary=()=>(0,make_ordered_dictionary_1.default)(exports.waMessageID);
exports.default=f=>{const g=f.socket,v=f.chatKey||(0,exports.waChatKey)(!0),x=f.labelAssociationKey||exports.waLabelAssociationKey,m=f.logger||Defaults_1.DEFAULT_CONNECTION_CONFIG.logger.child({stream:"in-mem-store"});f=require("@adiwajshing/keyed-db").default;const n=new f(v,b=>b.id),h={},l={},p={},u={},y={connection:"close"},q=new object_repository_1.ObjectRepository,r=new f(x,x.key),t=b=>{h[b]||(h[b]=makeMessagesDictionary());return h[b]},w=b=>{const a=new Set(Object.keys(l));for(const c of b)a.delete(c.id),
l[c.id]=Object.assign(l[c.id]||{},c);return a},z=()=>({chats:n,contacts:l,messages:h,labels:q,labelAssociations:r}),A=b=>{n.upsert(...b.chats);r.upsert(...(b.labelAssociations||[]));w(Object.values(b.contacts));var a=Object.values(b.labels||{});for(const c of a)q.upsertById(c.id,c);for(const c in b.messages){a=t(c);for(const d of b.messages[c])a.upsert(WAProto_1.proto.WebMessageInfo.fromObject(d),"append")}};return{chats:n,contacts:l,messages:h,groupMetadata:p,state:y,presences:u,labels:q,labelAssociations:r,
bind:b=>{b.on("connection.update",a=>{Object.assign(y,a)});b.on("messaging-history.set",({chats:a,contacts:c,messages:d,isLatest:e})=>{if(e){n.clear();for(const k in h)delete h[k]}a=n.insertIfAbsent(...a).length;m.debug({chatsAdded:a},"synced chats");a=w(c);if(e)for(const k of a)delete l[k];m.debug({deletedContacts:e?a.size:0,newContacts:c},"synced contacts");for(const k of d)t(k.key.remoteJid).upsert(k,"prepend");m.debug({messages:d.length},"synced messages")});b.on("contacts.upsert",a=>{w(a)});
b.on("contacts.update",async a=>{var c;for(const d of a){l[d.id]?a=l[d.id]:(a=await Promise.all(Object.keys(l).map(async e=>{const {user:k}=(0,WABinary_1.jidDecode)(e);return[e,(await (0,Utils_1.md5)(Buffer.from(k+"WA_ADD_NOTIF","utf8"))).toString("base64").slice(0,3)]})),a=l[(null===(c=a.find(([,e])=>e===d.id))||void 0===c?void 0:c[0])||""]);if(a)"changed"===d.imgUrl?a.imgUrl=g?await (null===g||void 0===g?void 0:g.profilePictureUrl(a.id)):void 0:"removed"===d.imgUrl&&delete a.imgUrl;else return m.debug({update:d},
"got update for non-existant contact");Object.assign(l[a.id],a)}});b.on("chats.upsert",a=>{n.upsert(...a)});b.on("chats.update",a=>{for(let c of a)n.update(c.id,d=>{0<c.unreadCount&&(c={...c},c.unreadCount=(d.unreadCount||0)+c.unreadCount);Object.assign(d,c)})||m.debug({update:c},"got update for non-existant chat")});b.on("labels.edit",a=>{if(a.deleted)return q.deleteById(a.id);if(20>q.count())return q.upsertById(a.id,a);m.error("Labels count exceed")});b.on("labels.association",({type:a,association:c})=>
{switch(a){case "add":r.upsert(c);break;case "remove":r.delete(c);break;default:console.error(`unknown operation type [${a}]`)}});b.on("presence.update",({id:a,presences:c})=>{u[a]=u[a]||{};Object.assign(u[a],c)});b.on("chats.delete",a=>{for(const c of a)n.get(c)&&n.deleteById(c)});b.on("messages.upsert",({messages:a,type:c})=>{switch(c){case "append":case "notify":for(const d of a)a=(0,WABinary_1.jidNormalizedUser)(d.key.remoteJid),t(a).upsert(d,"append"),"notify"===c&&(n.get(a)||b.emit("chats.upsert",
[{id:a,conversationTimestamp:(0,Utils_1.toNumber)(d.messageTimestamp),unreadCount:1}]))}});b.on("messages.update",a=>{var c;for(const {update:d,key:e}of a){a=t((0,WABinary_1.jidNormalizedUser)(e.remoteJid));if(null===d||void 0===d?0:d.status){const k=null===(c=a.get(e.id))||void 0===c?void 0:c.status;k&&(null===d||void 0===d?void 0:d.status)<=k&&(m.debug({update:d,storedStatus:k},"status stored newer then update"),delete d.status,m.debug({update:d},"new update object"))}a.updateAssign(e.id,d)||m.debug({update:d},
"got update for non-existent message")}});b.on("messages.delete",a=>{if("all"in a)a=h[a.jid],null===a||void 0===a||a.clear();else{const c=h[a.keys[0].remoteJid];if(c){const d=new Set(a.keys.map(e=>e.id));c.filter(e=>!d.has(e.key.id))}}});b.on("groups.update",a=>{for(const c of a)a=c.id,p[a]?Object.assign(p[a],c):m.debug({update:c},"got update for non-existant group metadata")});b.on("group-participants.update",({id:a,participants:c,action:d})=>{if(a=p[a])switch(d){case "add":a.participants.push(...c.map(e=>
({id:e,isAdmin:!1,isSuperAdmin:!1})));break;case "demote":case "promote":for(const e of a.participants)c.includes(e.id)&&(e.isAdmin="promote"===d);break;case "remove":a.participants=a.participants.filter(e=>!c.includes(e.id))}});b.on("message-receipt.update",a=>{for(const {key:c,receipt:d}of a)a=h[c.remoteJid],(a=null===a||void 0===a?void 0:a.get(c.id))&&(0,Utils_1.updateMessageWithReceipt)(a,d)});b.on("messages.reaction",a=>{for(const {key:c,reaction:d}of a)a=h[c.remoteJid],(a=null===a||void 0===
a?void 0:a.get(c.id))&&(0,Utils_1.updateMessageWithReaction)(a,d)})},loadMessages:async(b,a,c)=>{b=t(b);const d=!c||"before"in c?"before":"after",e=c?"before"in c?c.before:c.after:void 0;c=e?b.get(e.id):void 0;!b||"before"!==d||e&&!c?b=[]:(c?(c=b.array.findIndex(k=>k.key.id===(null===e||void 0===e?void 0:e.id)),b=b.array.slice(0,c)):b=b.array,0>a-b.length&&(b=b.slice(-a)));return b},getLabels:()=>q,getChatLabels:b=>r.filter(a=>a.chatId===b).all(),getMessageLabels:b=>r.filter(a=>a.messageId===b).all().map(({labelId:a})=>
a),loadMessage:async(b,a)=>{var c;return null===(c=h[b])||void 0===c?void 0:c.get(a)},mostRecentMessage:async b=>{var a;return null===(a=h[b])||void 0===a?void 0:a.array.slice(-1)[0]},fetchImageUrl:async(b,a)=>{const c=l[b];if(!c)return null===a||void 0===a?void 0:a.profilePictureUrl(b);"undefined"===typeof c.imgUrl&&(c.imgUrl=await (null===a||void 0===a?void 0:a.profilePictureUrl(b)));return c.imgUrl},fetchGroupMetadata:async(b,a)=>{p[b]||(a=await (null===a||void 0===a?void 0:a.groupMetadata(b)))&&
(p[b]=a);return p[b]},fetchMessageReceipts:async({remoteJid:b,id:a})=>{b=h[b];a=null===b||void 0===b?void 0:b.get(a);return null===a||void 0===a?void 0:a.userReceipt},toJSON:z,fromJSON:A,writeToFile:b=>{const {writeFileSync:a}=require("fs");a(b,JSON.stringify(z()))},readFromFile:b=>{const {readFileSync:a,existsSync:c}=require("fs");c(b)&&(m.debug({path:b},"reading from file"),b=a(b,{encoding:"utf-8"}),b=JSON.parse(b),A(b))}}};
